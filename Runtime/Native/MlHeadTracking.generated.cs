//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native
{
    using System.Runtime.InteropServices;

    internal static class MlHeadTracking
    {
        /// <summary>
        /// A set of possible error conditions that can cause Head Tracking to be less than ideal
        /// </summary>
        public enum MLHeadTrackingError : int
        {
            /// <summary>
            /// No error, tracking is nominal
            /// </summary>
            None,

            /// <summary>
            /// There are not enough features in the environment
            /// </summary>
            NotEnoughFeatures,

            /// <summary>
            /// Lighting in the environment is not sufficient to track accurately
            /// </summary>
            LowLight,

            /// <summary>
            /// Head tracking failed for an unkown reason
            /// </summary>
            Unknown,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLHeadTrackingError_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// A set of possible tracking modes the Head Tracking system can be in
        /// </summary>
        public enum MLHeadTrackingMode : int
        {
            /// <summary>
            /// Full 6 degrees of freedom tracking (position and orientation)
            /// </summary>
            SixDOF,

            /// <summary>
            /// Limited 3 degrees of freedom tracking (orientation only)
            /// </summary>
            /// <remarks>
            /// Use MLHeadTrackingMode_Unavailable instead
            /// </remarks>
            ThreeDOF,

            /// <summary>
            /// Head tracking is unavailable
            /// </summary>
            Unavailable = unchecked((int)ThreeDOF),

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLHeadTrackingMode_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Different types of map events that can occur that a developer may have to handle
        /// @apilevel 2
        /// </summary>
        [Flags]
        public enum MLHeadTrackingMapEvent : int
        {
            /// <summary>
            /// Map was lost It could possibly recover
            /// </summary>
            Lost = unchecked((int)(1 << (int)0)),

            /// <summary>
            /// Previous map was recovered
            /// </summary>
            Recovered = unchecked((int)(1 << (int)1)),

            /// <summary>
            /// Failed to recover previous map
            /// </summary>
            RecoveryFailed = unchecked((int)(1 << (int)2)),

            /// <summary>
            /// New map session created
            /// </summary>
            NewSession = unchecked((int)(1 << (int)3)),
        }

        /// <summary>
        /// Static information about a Head Tracker Populate this structure with MLHeadTrackingGetStaticData
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLHeadTrackingStaticData
        {
            /// <summary>
            /// Coordinate frame ID
            /// </summary>
            public MlTypes.MLCoordinateFrameUID coord_frame_head;
        }

        /// <summary>
        /// A structure containing information on the current state of the Head Tracking system
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLHeadTrackingState
        {
            /// <summary>
            /// What tracking mode the Head Tracking system is currently in
            /// </summary>
            public MlHeadTracking.MLHeadTrackingMode mode;

            /// <summary>
            /// A confidence value (from [0, 1]) representing the confidence in the current pose estimation
            /// </summary>
            public float confidence;

            /// <summary>
            /// Represents what tracking error (if any) is present
            /// </summary>
            public MlHeadTracking.MLHeadTrackingError error;

            public override string ToString()
            {
                return $"{nameof(MLHeadTrackingState)}|{nameof(mode)}:{mode}|{nameof(confidence)}:{confidence}|{nameof(error)}:{error}";
            }
        }

        /// <summary>
        /// Create a Head Tracker
        /// MLResult_Ok The head tracker was created successfully
        /// MLResult_UnspecifiedFailure The head tracker failed to create successfully
        /// </summary>
        /// <param name="out_handle">A pointer to an MLHandle which will contain the handle of the head tracker
        /// If this operation fails, out_handle will be ML_INVALID_HANDLE</param>
        /// <remarks>
        /// @priv LowLatencyLightwear
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLHeadTrackingCreate(ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Destroy a Head Tracker
        /// MLResult_Ok If the tracker was successfully destroyed
        /// MLResult_UnspecifiedFailure The head tracker was not successfully destroyed
        /// </summary>
        /// <param name="head_tracker">A handle to a Head Tracker created by MLHeadTrackingCreate</param>
        /// <remarks>
        /// @priv LowLatencyLightwear
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLHeadTrackingDestroy(MlApi.MLHandle head_tracker);

        /// <summary>
        /// Return static information about the Head Tracker
        /// MLResult_InvalidParam The out_data pointer was not valid (null)
        /// MLResult_Ok The static data was successfully received
        /// MLResult_UnspecifiedFailure The static data could not be received
        /// </summary>
        /// <param name="head_tracker">A handle to the tracker</param>
        /// <param name="out_data">Target to populate the data about that Head Tracker</param>
        /// <remarks>
        /// @priv LowLatencyLightwear
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLHeadTrackingGetStaticData(MlApi.MLHandle head_tracker, ref MlHeadTracking.MLHeadTrackingStaticData out_data);

        /// <summary>
        /// Return the most recent Head Tracking state
        /// MLResult_InvalidParam The out_state parameter was not valid (null)
        /// MLResult_Ok The state was successfully received
        /// MLResult_UnspecifiedFailure Failed to receive the head tracking state
        /// </summary>
        /// <param name="head_tracker">A handle to the tracker</param>
        /// <param name="out_state">Pointer to valid MLHeadTrackingState object to be filled with current state information</param>
        /// <remarks>
        /// @priv LowLatencyLightwear
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLHeadTrackingGetState(MlApi.MLHandle head_tracker, ref MlHeadTracking.MLHeadTrackingState out_state);

        /// <summary>
        /// Get map events
        /// MLResult_InvalidParam out_map_events was not valid (null)
        /// MLResult_Ok Operation succeeded
        /// MLResult_UnspecifiedFailure Operation failed
        /// </summary>
        /// <param name="head_tracker">A handle to the tracker</param>
        /// <param name="out_map_events">Pointer to a uint64_t representing a bitmask of
        /// MLHeadTrackerMapEvents, allocated by the caller</param>
        /// <remarks>
        /// A developer must be aware of certain events that can occur under degenerative conditions
        /// in order to cleanly handle it The most important event to be aware of is when a map changes
        /// In the case that a new map session begins, or recovery fails, all formerly cached transform
        /// and world reconstruction data (raycast, planes, mesh) is invalidated and must be updated
        /// @apilevel 2
        /// @priv LowLatencyLightwear
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLHeadTrackingGetMapEvents(MlApi.MLHandle head_tracker, ref ulong out_map_events);
    }
}
