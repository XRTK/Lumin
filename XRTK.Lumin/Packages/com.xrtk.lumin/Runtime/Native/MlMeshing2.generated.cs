//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native
{
    using System.Runtime.InteropServices;

    internal static class MlMeshing2
    {
        /// <summary>
        /// Request flags for the meshing system
        /// </summary>
        [Flags]
        public enum MeshingFlags : int
        {
            /// <summary>
            /// If set, will return a point cloud instead of a triangle mesh
            /// </summary>
            PointCloud = unchecked((int)1 << (int)0),

            /// <summary>
            /// If set, the system will compute the normals for the triangle vertices
            /// </summary>
            ComputeNormals = unchecked((int)1 << (int)1),

            /// <summary>
            /// If set, the system will compute the confidence values
            /// </summary>
            ComputeConfidence = unchecked((int)1 << (int)2),

            /// <summary>
            /// If set, the system will planarize the returned mesh (planar regions will be smoothed out)
            /// </summary>
            Planarize = unchecked((int)1 << (int)3),

            /// <summary>
            /// If set, the mesh skirt (overlapping area between two mesh blocks) will be removed
            /// </summary>
            RemoveMeshSkirt = unchecked((int)1 << (int)4),

            /// <summary>
            /// If set, winding order of indices will be be changed from clockwise to counter clockwise
            /// This could be useful for face culling process in different engines
            /// </summary>
            IndexOrderCCW = unchecked((int)1 << (int)5),

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMeshingFlags_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Level of detail of the block mesh
        /// </summary>
        public enum MLMeshingLOD : int
        {
            /// <summary>
            /// Minimum Level of Detail (LOD) for the mesh
            /// </summary>
            Minimum,

            /// <summary>
            /// Medium Level of Detail (LOD) for the mesh
            /// </summary>
            Medium,

            /// <summary>
            /// Maximum Level of Detail (LOD) for the mesh
            /// </summary>
            Maximum,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMeshingLOD_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Result of a mesh request
        /// </summary>
        public enum MLMeshingResult : int
        {
            /// <summary>
            /// Mesh request has succeeded
            /// </summary>
            Success,

            /// <summary>
            /// Mesh request has failed
            /// </summary>
            Failed,

            /// <summary>
            /// Mesh request is pending
            /// </summary>
            Pending,

            /// <summary>
            /// There are partial updates on the mesh request
            /// </summary>
            PartialUpdate,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMeshingResult_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// State of a block mesh
        /// </summary>
        public enum MLMeshingMeshState : int
        {
            /// <summary>
            /// Mesh has been created
            /// </summary>
            New,

            /// <summary>
            /// Mesh has been updated
            /// </summary>
            Updated,

            /// <summary>
            /// Mesh has been deleted
            /// </summary>
            Deleted,

            /// <summary>
            /// Mesh is unchanged
            /// </summary>
            Unchanged,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMeshingMeshState_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Mesh Settings for the underlying system
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLMeshingSettings
        {
            /// <summary>
            /// Request flags that are a combination of MLMeshingFlags
            /// </summary>
            public MeshingFlags flags;

            /// <summary>
            /// Perimeter (in meters) of holes you wish to have filled
            /// </summary>
            public float fill_hole_length;

            /// <summary>
            /// Any component that is disconnected from the main mesh and
            /// which has an area (in meters^2) less than this size will be removed
            /// </summary>
            public float disconnected_component_area;

            public static MLMeshingSettings Default
            {
                get
                {
                    return new MLMeshingSettings
                    {
                        flags = MeshingFlags.Planarize |
                                MeshingFlags.IndexOrderCCW |
                                MeshingFlags.RemoveMeshSkirt,
                        fill_hole_length = 5f,
                        disconnected_component_area = 0.25f,
                    };
                }
            }
        }

        /// <summary>
        /// Axis aligned bounding box for querying updated mesh info
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLMeshingExtents
        {
            /// <summary>
            /// The center of the bounding box
            /// </summary>
            public MlTypes.MLVec3f center;

            /// <summary>
            /// The rotation of the bounding box
            /// </summary>
            public MlTypes.MLQuaternionf rotation;

            /// <summary>
            /// The size of the bounding box
            /// When a mesh request is complete all mesh blocks that intersect with the
            /// extents provided here will be returned in <see cref="MLMeshingMeshInfo"/>
            /// </summary>
            public MlTypes.MLVec3f extents;
        }

        /// <summary>
        /// Representation of a mesh block
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLMeshingBlockInfo
        {
            /// <summary>
            /// The coordinate frame UID to represent the block
            /// </summary>
            public MlTypes.MLCoordinateFrameUID id;

            /// <summary>
            /// The extents of the bounding box
            /// </summary>
            public MlMeshing2.MLMeshingExtents extents;

            /// <summary>
            /// The timestamp (in microseconds) when block was updated
            /// </summary>
            public ulong timestamp;

            /// <summary>
            /// The state of the Mesh Block
            /// </summary>
            public MlMeshing2.MLMeshingMeshState state;
        }

        /// <summary>
        /// Response structure for the mesh block info
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLMeshingMeshInfo
        {
            /// <summary>
            /// The response timestamp (in microseconds) to a earlier request
            /// </summary>
            public ulong timestamp;

            /// <summary>
            /// The number of responses in data pointer
            /// </summary>
            public uint data_count;

            /// <summary>
            /// The meshinfo returned by the system
            /// </summary>
            public MLMeshingBlockInfo data;
        }

        /// <summary>
        /// Request structure to get the actual mesh for a block
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLMeshingBlockRequest
        {
            /// <summary>
            /// The UID to represent the block
            /// </summary>
            public MlTypes.MLCoordinateFrameUID id;

            /// <summary>
            /// The LOD level to request
            /// </summary>
            public MlMeshing2.MLMeshingLOD level;
        }

        /// <summary>
        /// Request structure to get the actual mesh for a set of blocks
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLMeshingMeshRequest
        {
            /// <summary>
            /// The number of blocks requested
            /// </summary>
            public int request_count;

            /// <summary>
            /// Per block request
            /// </summary>
            public MLMeshingBlockRequest data;
        }

        /// <summary>
        /// Final structure for a block mesh
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLMeshingBlockMesh
        {
            /// <summary>
            /// The result of the meshing
            /// </summary>
            public MlMeshing2.MLMeshingResult result;

            /// <summary>
            /// The coordinate FrameID of the block
            /// </summary>
            public MlTypes.MLCoordinateFrameUID id;

            /// <summary>
            /// The LOD level of the meshing request
            /// </summary>
            public MlMeshing2.MLMeshingLOD level;

            /// <summary>
            /// The settings with which meshing took place
            /// </summary>
            public uint flags;

            /// <summary>
            /// The number of indices in index buffer
            /// </summary>
            public ushort index_count;

            /// <summary>
            /// The number of vertices in vertex/normal/confidence buffer
            /// </summary>
            public uint vertex_count;

            /// <summary>
            /// Pointer to the vertex buffer
            /// </summary>
            public MlTypes.MLVec3f vertex;

            /// <summary>
            /// Pointer to index buffer
            /// In the index buffer each value is the index of a vertex in the vertex
            /// buffer Three indices define one triangle For example, the first triangle
            /// will have the vertices: vertex[index[0]], vertex[index[1]], vertex[index[2]]
            /// Index order is defined by the MLMeshingFlags_IndexOrderCCW flag
            /// </summary>
            public ushort index;

            /// <summary>
            /// Pointer to normals buffer
            /// </summary>
            public MlTypes.MLVec3f normal;

            /// <summary>
            /// Pointer to confidence buffer
            /// </summary>
            public float confidence;
        }

        /// <summary>
        /// Result of a Mesh request <see cref="MLMeshingGetMeshResult"/>
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLMeshingMesh
        {
            /// <summary>
            /// The result of the meshing Can have partial updates
            /// </summary>
            public MlMeshing2.MLMeshingResult result;

            /// <summary>
            /// The timestamp (in microseconds) when data was generated
            /// </summary>
            public ulong timestamp;

            /// <summary>
            /// Number of meshes available in data
            /// </summary>
            public uint data_count;

            /// <summary>
            /// The mesh data
            /// </summary>
            public MLMeshingBlockMesh data;
        }

        /// <summary>
        /// Create the meshing client
        /// MLResult_InvalidParam Meshing Client was not created due to an invalid parameter
        /// MLResult_Ok Meshing Client was created successfully
        /// MLResult_PrivilegeDenied Client was not created due to insufficient privilege
        /// MLResult_UnspecifiedFailure Meshing Client was not created due to an unknown error
        /// </summary>
        /// <param name="out_client_handle">The handle to the created client</param>
        /// <param name="settings">The initial settings to be used for meshing</param>
        /// <remarks>
        /// Note that this will be the only function in the meshing API that will return MLResult_PrivilegeDenied
        /// Trying to call the other functions with an invalid MLHandle will result in MLResult_InvalidParam
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingCreateClient(ref MlApi.MLHandle out_client_handle, in MlMeshing2.MLMeshingSettings settings);

        /// <summary>
        /// Free the client resources
        /// MLResult_InvalidParam Meshing Client was not destroyed due to an invalid parameter
        /// MLResult_Ok Meshing Client was destroyed successfully
        /// </summary>
        /// <param name="client_handle">The client to destroy</param>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingDestroyClient(ref MlApi.MLHandle client_handle);

        /// <summary>
        /// Initialize the meshing settings with system defaults
        /// MLResult_InvalidParam Mesh Settings were not initialized due to an invalid parameter
        /// MLResult_Ok Mesh Settings were initialized successfully
        /// </summary>
        /// <param name="out_settings">The initial settings to be used for meshing</param>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingInitSettings(ref MlMeshing2.MLMeshingSettings out_settings);

        /// <summary>
        /// Update the meshing settings at runtime
        /// MLResult_InvalidParam Mesh Settings were not updated due to an invalid parameter
        /// MLResult_Ok Mesh Settings were updated successfully
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="settings">The updated settings to be used for meshing</param>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingUpdateSettings(MlApi.MLHandle client_handle, in MlMeshing2.MLMeshingSettings settings);

        /// <summary>
        /// Request the Mesh Info which includes CFUIDs and bounding extents of the blocks
        /// MLResult_InvalidParam Mesh info was not requested due to an invalid parameter
        /// MLResult_Ok Mesh Info was requested successfully
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="extents">The region of interest for meshing</param>
        /// <param name="out_request_handle">The handle for the current request Needs to be passed to query the result of the request</param>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingRequestMeshInfo(MlApi.MLHandle client_handle, in MlMeshing2.MLMeshingExtents extents, ref MlApi.MLHandle out_request_handle);

        /// <summary>
        /// Get the Result of a previous MeshInfo request
        /// MLResult_InvalidParam Mesh Settings were not updated due to an invalid parameter
        /// MLResult_Ok Mesh Info was populated successfully
        /// MLResult_Peding Mesh Info is pending update
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="request_handle">The handle populated in a prev MLMeshingGetMeshInfo</param>
        /// <param name="out_info">The final result which will be populated only if the result is successful</param>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingGetMeshInfoResult(MlApi.MLHandle client_handle, MlApi.MLHandle request_handle, ref MlMeshing2.MLMeshingMeshInfo out_info);

        /// <summary>
        /// Request the Mesh for all CFUIDs populated in request
        /// MLResult_InvalidParam Meshes were not requested due to an invalid parameter
        /// MLResult_Ok Meshes were requested successfully
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="request">The request for meshes of interest</param>
        /// <param name="out_request_handle">The handle for the current request Needs to be passed to query the result of the request</param>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingRequestMesh(MlApi.MLHandle client_handle, in MlMeshing2.MLMeshingMeshRequest request, ref MlApi.MLHandle out_request_handle);

        /// <summary>
        /// Get the Result of a previous Mesh request
        /// MLResult_InvalidParam Meshes were not updated due to an invalid parameter
        /// MLResult_Ok Meshes was populated successfully
        /// MLResult_Peding Meshes pending update
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="request_handle">The handle populated in a prev MLMeshingGetMesh</param>
        /// <param name="out_mesh">The final result which will be populated only if the result is successful</param>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingGetMeshResult(MlApi.MLHandle client_handle, MlApi.MLHandle request_handle, ref MlMeshing2.MLMeshingMesh out_mesh);

        /// <summary>
        /// Free resources created by the meshing APIS Needs to be called whenever MLMeshingGetMeshInfoResult,
        /// MLMeshingGetMeshResult return a success
        /// MLResult_InvalidParam Resources were not freed due to an invalid parameter
        /// MLResult_Ok Resources were freed successfully
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="request_handle">The handle populated in a prev request</param>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingFreeResource(MlApi.MLHandle client_handle, ref MlApi.MLHandle request_handle);
    }
}
