//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using UnityEngine;
using System.Globalization;

namespace XRTK.Lumin.Runtime.Native
{
    using System.Runtime.InteropServices;

    internal static class MlTypes
    {
        /// <summary>
        /// 2D vector represented with X and Y floats
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLVec2f
        {
            public float x;
            public float y;

            private MLVec2f(float x, float y)
            {
                this.x = x;
                this.y = y;
            }

            public static explicit operator Vector2(MLVec2f v2) => new Vector2(v2.x, v2.y);
            public static explicit operator MLVec2f(Vector2 v2) => new MLVec2f(v2.x, v2.y);
        }

        /// <summary>
        /// 3D vector represented with X, Y, and Z floats
        /// </summary>
        [Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct MLVec3f
        {
            public float x;
            public float y;
            public float z;

            private MLVec3f(float x, float y, float z)
            {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            public static explicit operator Vector3(MLVec3f v3) => new Vector3(v3.x, v3.y, -v3.z);
            public static explicit operator MLVec3f(Vector3 v3) => new MLVec3f(v3.x, v3.y, -v3.z);
        }

        /// <summary>
        /// Quaternion stored as X, Y, Z, W floats
        /// </summary>
        [Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct MLQuaternionf
        {
            public float x;
            public float y;
            public float z;
            public float w;

            private MLQuaternionf(float x, float y, float z, float w)
            {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }

            public static explicit operator Quaternion(MLQuaternionf q) => new Quaternion(q.x, q.y, -q.z, -q.w);
            public static explicit operator MLQuaternionf(Quaternion q) => new MLQuaternionf(q.x, q.y, -q.z, -q.w);

            public static MLQuaternionf Identity()
            {
                MLQuaternionf identity = new MLQuaternionf()
                {
                    x = 0,
                    y = 0,
                    z = 0,
                    w = 1
                };

                return identity;
            }
        }

        /// <summary>
        /// Information used to transform from one coordinate frame to another
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLTransform
        {
            /// <summary>
            /// The rotation of the coordinate frame to apply after the translation
            /// </summary>
            public MlTypes.MLQuaternionf rotation;

            /// <summary>
            /// The translation to apply to get to the coordinate frame in the proper
            /// location
            /// </summary>
            public MlTypes.MLVec3f position;

            private MLTransform(MlTypes.MLVec3f position, MlTypes.MLQuaternionf rotation)
            {
                this.position = position;
                this.rotation = rotation;
            }

            public static explicit operator Matrix4x4(MLTransform t) => Matrix4x4.TRS((Vector3)t.position, (Quaternion)t.rotation, Vector3.one);
            public static explicit operator MLTransform(Matrix4x4 m) => new MLTransform((MlTypes.MLVec3f)(Vector3)m.GetColumn(3), (MlTypes.MLQuaternionf)Quaternion.LookRotation(m.GetColumn(2), m.GetColumn(1)));

            public static MLTransform Identity()
            {
                MLTransform t = new MLTransform();
                t.rotation = MLQuaternionf.Identity();
                return t;
            }
        }

        /// <summary>
        /// An arbitrary 4x4 matrix represented with an array of floats
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct MLMat4f
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
            public float[] matrix_colmajor;
        }

        /// <summary>
        /// 2D rectangle in native format.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLRectf
        {
            /// <summary>
            /// The x coordinate.
            /// </summary>
            public float x;

            /// <summary>
            /// The y coordinate.
            /// </summary>
            public float y;

            /// <summary>
            /// The width.
            /// </summary>
            public float w;

            /// <summary>
            /// The height.
            /// </summary>
            public float h;
        }

        /// <summary>
        /// Universally Unique Identifier
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLUUID
        {
            /// <summary>
            /// The TimeLow field.
            /// </summary>
            public uint TimeLow;

            /// <summary>
            /// The TimeMid field.
            /// </summary>
            public ushort TimeMid;

            /// <summary>
            /// The TimeHiAndVersion field.
            /// </summary>
            public ushort TimeHiAndVersion;

            /// <summary>
            /// The <c>ClockSeqHiAndReserved</c> field.
            /// </summary>
            public byte ClockSeqHiAndReserved;

            /// <summary>
            /// The <c>ClockSeqLow</c> field.
            /// </summary>
            public byte ClockSeqLow;

            /// <summary>
            /// The Node0 field.
            /// </summary>
            public byte Node0;

            /// <summary>
            /// The Node1 field.
            /// </summary>
            public byte Node1;

            /// <summary>
            /// The Node2 field.
            /// </summary>
            public byte Node2;

            /// <summary>
            /// The Node3 field.
            /// </summary>
            public byte Node3;

            /// <summary>
            /// The Node4 field.
            /// </summary>
            public byte Node4;

            /// <summary>
            /// The Node5 field.
            /// </summary>
            public byte Node5;


            public static explicit operator Guid(MLUUID uuid) => new Guid(uuid.TimeLow, uuid.TimeMid, uuid.TimeHiAndVersion, uuid.ClockSeqHiAndReserved, uuid.ClockSeqLow, uuid.Node0, uuid.Node1, uuid.Node2, uuid.Node3, uuid.Node4, uuid.Node5);
            public static explicit operator MLUUID(Guid guid)
            {
                var result = new MLUUID();
                var guidString = guid.ToString("N");

                result.TimeLow = uint.Parse(guidString.Substring(0, 8), NumberStyles.HexNumber);
                result.TimeMid = ushort.Parse(guidString.Substring(8, 4), NumberStyles.HexNumber);
                result.TimeHiAndVersion = ushort.Parse(guidString.Substring(12, 4), NumberStyles.HexNumber);
                result.ClockSeqHiAndReserved = byte.Parse(guidString.Substring(16, 2), NumberStyles.HexNumber);
                result.ClockSeqLow = byte.Parse(guidString.Substring(18, 2), NumberStyles.HexNumber);
                result.Node0 = byte.Parse(guidString.Substring(20, 2), NumberStyles.HexNumber);
                result.Node1 = byte.Parse(guidString.Substring(22, 2), NumberStyles.HexNumber);
                result.Node2 = byte.Parse(guidString.Substring(24, 2), NumberStyles.HexNumber);
                result.Node3 = byte.Parse(guidString.Substring(26, 2), NumberStyles.HexNumber);
                result.Node4 = byte.Parse(guidString.Substring(28, 2), NumberStyles.HexNumber);
                result.Node5 = byte.Parse(guidString.Substring(30, 2), NumberStyles.HexNumber);

                return result;
            }
        }

        /// <summary>
        /// A unique identifier which represents a coordinate frame.
        /// The unique identifier is comprised of two values.
        /// </summary>
        [Serializable]
        [StructLayout(LayoutKind.Sequential)]
        public struct MLCoordinateFrameUID : IEquatable<MLCoordinateFrameUID>
        {
            /// <summary>
            /// The first data value.
            /// </summary>
            public ulong First;

            /// <summary>
            /// The second data value.
            /// </summary>
            public ulong Second;

            /// <summary>
            /// Gets an initialized MLCoordinateFrameUID.
            /// </summary>
            /// <returns>An initialized MLCoordinateFrameUID.</returns>
            public static MLCoordinateFrameUID EmptyFrame => new MLCoordinateFrameUID();

            /// <summary>
            /// The equality check to be used for comparing two MLCoordinateFrameUID structs.
            /// </summary>
            /// <param name="one">The first struct to compare with the second struct. </param>
            /// <param name="two">The second struct to compare with the first struct. </param>
            /// <returns>True if the two provided structs have the same two data values.</returns>
            public static bool operator ==(MLCoordinateFrameUID one, MLCoordinateFrameUID two)
            {
                return one.First == two.First && one.Second == two.Second;
            }

            /// <summary>
            /// The inequality check to be used for comparing two MLCoordinateFrameUID structs.
            /// </summary>
            /// <param name="one">The first struct to compare with the second struct. </param>
            /// <param name="two">The second struct to compare with the first struct. </param>
            /// <returns>True if the two provided structs do not have the same two data values.</returns>
            public static bool operator !=(MLCoordinateFrameUID one, MLCoordinateFrameUID two)
            {
                return !(one == two);
            }

            /// <summary>
            /// The equality check to be used for when being compared to an object.
            /// </summary>
            /// <param name="obj">The object to compare to this one with.</param>
            /// <returns>True if the the provided object is of the MLCoordinateFrameUID type and has the same two data values.</returns>
            public override bool Equals(object obj)
            {
                return obj is MLCoordinateFrameUID other && Equals(other);
            }

            /// <summary>
            /// The equality check to be used for when being compared to an object.
            /// </summary>
            /// <param name="other">The object to compare to this one with.</param>
            /// <returns>True if the the provided object is of the MLCoordinateFrameUID type and has the same two data values.</returns>
            public bool Equals(MLCoordinateFrameUID other)
            {
                return First == other.First && Second == other.Second;
            }

            /// <summary>
            /// Gets the hash code to use from the first data value.
            /// </summary>
            /// <returns>The hash code returned by the first data value of this object </returns>
            public override int GetHashCode()
            {
                unchecked
                {
                    return (First.GetHashCode() * 397) ^ Second.GetHashCode();
                }
            }

            /// <summary>
            /// Returns the string value of the GUID of this MLCoordinateFrameUID.
            /// </summary>
            /// <returns>The string value of the GUID.</returns>
            public override string ToString()
            {
                return $"{First:X16}-{Second:X16}";
            }

            /// <summary>
            /// Returns the GUID based on the values of this MLCoordinateFrameUID.
            /// </summary>
            /// <returns>The calculated GUID.</returns>
            public Guid ToGuid()
            {
                byte[] toConvert = BitConverter.GetBytes(this.First);
                byte[] newSecond = BitConverter.GetBytes(this.Second);
                FlipGuidComponents(toConvert);
                ulong newFirst = BitConverter.ToUInt64(toConvert, 0);

                return new Guid((int)(newFirst >> 32 & 0x00000000FFFFFFFF), (short)(newFirst >> 16 & 0x000000000000FFFF), (short)(newFirst & 0x000000000000FFFF), newSecond);
            }

            /// <summary>
            /// Flips a component of the GUID based on <c>endianness</c>.
            /// </summary>
            /// <param name="bytes">The array of bytes to reverse.</param>
            private static void FlipGuidComponents(byte[] bytes)
            {
                if (BitConverter.IsLittleEndian)
                {
                    Array.Reverse(bytes);
                }
            }
        }
    }
}
