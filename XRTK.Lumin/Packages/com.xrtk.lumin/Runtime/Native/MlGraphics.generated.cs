//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Runtime.Native
{
    using System.Runtime.InteropServices;

    internal static class MlGraphics
    {
        /// <summary>
        /// The graphics flags used as part of client creation
        /// </summary>
        /// <remarks>
        /// The flags are used to define the graphics_flags member of the MLGraphicsOptions as
        /// part of the definition to create the client
        /// </remarks>
        [Flags]
        public enum MLGraphicsFlags : int
        {
            /// <summary>
            /// The client will not provide a depth buffer to the graphics system
            /// as part of rendering Therefore the handle returned for all depth related
            /// resources from the graphics APIs will be invalid
            /// </summary>
            MLGraphicsFlags_NoDepth = unchecked((int)1 << (int)0),

            /// <summary>
            /// Create a debug client with a debug configuration that provides extended logcat
            /// error logging Useful to debug failures in API calls to the graphics system
            /// </summary>
            MLGraphicsFlags_DebugMode = unchecked((int)1 << (int)2),

            /// <summary>
            /// When graphics_flags is set to default, the client configuration returned
            /// is the default configuration (color/depth, origin lower left, non-debug)
            /// </summary>
            MLGraphicsFlags_Default = unchecked((int)0),

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLGraphicsFlags_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// The definition of the supported color/depth surface formats
        /// </summary>
        /// <remarks>
        /// Formats that can be specified for the color_format and depth_format in
        /// MLGraphicsOptions For the best quality the recommended color format is
        /// MLSurfaceFormat_RGBA8UNormSRGB, and for depth (when defined) either
        /// MLSurfaceFormat_D32Float or MLSurfaceFormat_D32FloatS8
        /// </remarks>
        public enum MLSurfaceFormat : int
        {
            /// <summary>
            /// Invalid format for color/depth
            /// </summary>
            MLSurfaceFormat_Unknown = unchecked((int)0),

            /// <summary>
            /// 32bit linear color format (RGBA8)
            /// </summary>
            MLSurfaceFormat_RGBA8UNorm,

            /// <summary>
            /// Gamma 22 32bit sRGB color format (RGBA8) Clients requesting this format
            /// are required to encode the final color into this surface as defined by the
            /// IEC 61966-2-1 specification
            /// </summary>
            MLSurfaceFormat_RGBA8UNormSRGB,

            /// <summary>
            /// 32bit linear color format (R10G10B10A2)
            /// </summary>
            MLSurfaceFormat_RGB10A2UNorm,

            /// <summary>
            /// 64bit linear color format (R16G16B16A16)
            /// </summary>
            MLSurfaceFormat_RGBA16Float,

            /// <summary>
            /// 32bit floating point depth buffer (D32F)
            /// </summary>
            MLSurfaceFormat_D32Float,

            /// <summary>
            /// 24bit linear depth format with 8bit stencil (D24S8)
            /// </summary>
            MLSurfaceFormat_D24NormS8,

            /// <summary>
            /// 32bit floating point depth format with 8bit stencil (D32FS8)
            /// </summary>
            MLSurfaceFormat_D32FloatS8,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLSurfaceFormat_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Frame timing hint specified at runtime to control the client cadence
        /// </summary>
        /// <remarks>
        /// Timing hint defines the requested client rate when interacting with
        /// the graphics system and is used as part of the blocking behavior specified by
        /// MLGraphicsBeginFrame The timing hit can be updated at runtime for a valid client
        /// at any time and will take effect on the next frame period for the client
        /// The recommended setting for the timing hint is MLGraphicsFrameTimingHint_60Hz
        /// </remarks>
        public enum MLGraphicsFrameTimingHint : int
        {
            /// <summary>
            /// Default rate is unspecified, adjusted based on system conditions
            /// </summary>
            MLGraphicsFrameTimingHint_Unspecified = unchecked((int)0),

            /// <summary>
            /// Run at the maximum rate allowed by the system
            /// </summary>
            MLGraphicsFrameTimingHint_Maximum,

            /// <summary>
            /// Run at a specified rate of 60Hz (ie one frame every ~1667 ms)
            /// </summary>
            MLGraphicsFrameTimingHint_60Hz,

            /// <summary>
            /// Run at a specified rate of 120Hz (ie one frame every ~833 ms)
            /// </summary>
            MLGraphicsFrameTimingHint_120Hz,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLGraphicsFrameTimingHint_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// The metadata name associated with each virtual camera
        /// </summary>
        /// <remarks>
        /// APIs within the graphics system will return information specific to
        /// a single virtual camera or both The metadata name informs the client
        /// how to correlate the outputs of the API to a specific camera or both
        /// cameras
        /// </remarks>
        public enum MLGraphicsVirtualCameraName : int
        {
            /// <summary>
            /// Name of the combined camera, the union of all virtual cameras
            /// </summary>
            MLGraphicsVirtualCameraName_Combined = unchecked((int)-1),

            /// <summary>
            /// Name of virtual camera for left display
            /// </summary>
            MLGraphicsVirtualCameraName_Left = unchecked((int)0),

            /// <summary>
            /// Name of virtual camera for right display
            /// </summary>
            MLGraphicsVirtualCameraName_Right,

            /// <summary>
            /// The maximum number of render virtual cameras
            /// </summary>
            MLGraphicsVirtualCameraName_Count,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLGraphicsVirtualCameraName_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// The number of buffered entries for each virtual camera
        /// </summary>
        public const int MLGraphics_BufferCount = unchecked((int)3);

        /// <summary>
        /// Defines the requested projection matrix model for rendering
        /// </summary>
        /// <remarks>
        /// Provided as part of the MLGraphicsFrameParams, defines the requested
        /// projection model for the intrinsic definition returned for each virtual
        /// camera from MLGraphicsBeginFrame
        /// The signed Z projection model is optimized for OpenGL use and transforms
        /// points into a left-hand, right-up-forward, Z range -1 (near) to 1 (far)
        /// projected coordinate space
        /// The reverse infinite Z projection model maps the Z range from 1 (near) to
        /// 0 (infinity)
        /// Vulkan clients should use the unsigned Z projection model to ensure that
        /// NDC points end up in Z range 0 (near) to 1 (far)
        /// </remarks>
        public enum MLGraphicsProjectionType : int
        {
            /// <summary>
            /// Projection model with signed Z
            /// </summary>
            MLGraphicsProjectionType_SignedZ = unchecked((int)0),

            /// <summary>
            /// Projection model reversed infinite Z
            /// </summary>
            MLGraphicsProjectionType_ReversedInfiniteZ = unchecked((int)1),

            /// <summary>
            /// Projection model with unsigned Z
            /// </summary>
            MLGraphicsProjectionType_UnsignedZ = unchecked((int)2),

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLGraphicsProjectionType_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        public const int MLGraphicsBlobCache_DefaultMaxEntryBytes = unchecked((int)512 * 1024);

        public const int MLGraphicsBlobCache_DefaultMaxTotalBytes = unchecked((int)8 * 1024 * 1024);

        /// <summary>
        /// The graphics options provided for client creation
        /// </summary>
        /// <remarks>
        /// MLGraphicsOptions defines the requested client configuration for
        /// creating GL/GLES or VK clients
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLGraphicsOptions
        {
            /// <summary>
            /// The combined graphics flags, as defined by MLGraphicsFlags
            /// </summary>
            public uint graphics_flags;

            /// <summary>
            /// The color surface format, defined in MLSurfaceFormat
            /// </summary>
            public MlGraphics.MLSurfaceFormat color_format;

            /// <summary>
            /// The depth surface format, defined in MLSurfaceFormat
            /// </summary>
            public MlGraphics.MLSurfaceFormat depth_format;
        }

        /// <summary>
        /// The frame parameters requested for the next rendered frame
        /// </summary>
        /// <remarks>
        /// The parameters defined by MLGraphicsFrameParamsEx are supplied to
        /// MLGraphicsBeginFrameEx from the client to define the requested
        /// characteristics of the next rendered frame
        /// This structure must be initialized by calling MLGraphicsFrameParamsExInit before use
        /// @apilevel 3
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLGraphicsFrameParamsEx
        {
            /// <summary>
            /// Struct API version
            /// </summary>
            public uint version;

            /// <summary>
            /// Requested near clip plane distance in meters
            /// </summary>
            public float near_clip;

            /// <summary>
            /// Far clipping plane distance in meters
            /// </summary>
            public float far_clip;

            /// <summary>
            /// Distance, in meters, to defined focus point for the client content The focus
            /// distance should be calculated as the positive distance to the client determined
            /// object of interest (relative to the forward vector of the Lightwear)
            /// </summary>
            public float focus_distance;

            /// <summary>
            /// Depth, in meters, for which to optimize content stabilization for time warp
            /// Stabilization depth should be calculated as the positive depth of content to be
            /// most stable under time warp (relative to the forward vector of the Lightwear)
            /// </summary>
            /// <remarks>
            /// This value should be set between focus_distance and far_clip It usually provides a better
            /// experience not having content farther than this distance, so a value close to the far clip
            /// is recommended The best value will depend on the actual depth distribution of content
            /// </remarks>
            public float stabilization_depth;

            /// <summary>
            /// The scale factor for the render surfaces, valid range is 00-&gt;10 When
            /// supplying a scale factor 
            /// &lt;
            /// 10 the viewport returned from MLGraphicsBeginFrame
            /// will be adjusted to the closest width/height match to the request that can
            /// be supported by the graphics system
            /// </summary>
            public float surface_scale;

            /// <summary>
            /// Enable the platform level vignette for this frame
            /// </summary>
            [MarshalAs(UnmanagedType.U1)]
            public bool vignette;

            /// <summary>
            /// Content for this frame is protected and should not be recorded or captured
            /// outside the graphics system
            /// </summary>
            [MarshalAs(UnmanagedType.U1)]
            public bool protected_surface;

            /// <summary>
            /// Requested projection model for rendering
            /// </summary>
            public MlGraphics.MLGraphicsProjectionType projection_type;
        }

        /// <summary>
        /// The static clip extents defined for all possible eye positions
        /// </summary>
        /// <remarks>
        /// Defines the conservative clip extents for the camera name that can be used for early
        /// update frustum culling in the client update path (prior to calling MLGraphicsBeginFrame)
        /// Note: The client will need to obtain a headpose to combine with the provided matrices
        /// (transform and projection) to define the frustum The general definition for camera from
        /// world (for the specified camera name) is MATprojection * inv(MATtransform) * inv(MATheadpose)
        /// for RHS multiplication
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLGraphicsClipExtentsInfo
        {
            /// <summary>
            /// The virtual camera meta data name
            /// </summary>
            public MlGraphics.MLGraphicsVirtualCameraName virtual_camera_name;

            /// <summary>
            /// The projection matrix, defined with infinite far clip plane distance If the client
            /// is using a different projection model the matrix will need to be adjusted to match
            /// the client model prior to frustum culling
            /// </summary>
            public MlTypes.MLMat4f projection;

            /// <summary>
            /// The camera to world transform (ie local space relative to the head)
            /// </summary>
            public MlTypes.MLTransform transform;
        }

        /// <summary>
        /// The clip extents parameters
        /// </summary>
        /// <remarks>
        /// The parameters defined by MLGraphicsClipExtentsParams are supplied to
        /// MLGraphicsGetClipExtentsEx from the client to define the requested
        /// characteristics of the clip extents
        /// @apilevel 4
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLGraphicsClipExtentsParams
        {
            /// <summary>
            /// Struct API version
            /// </summary>
            public uint version;
        }

        /// <summary>
        /// The clip extents array returned from MLGraphicsGetClipExtentsEx
        /// </summary>
        /// <remarks>
        /// The clip extents array provides the conservative clip extents per metadata
        /// camera as defined by MLGraphicsClipExtentsInfo
        /// This structure must be initialized by calling MLGraphicsClipExtentsInfoArrayExInit before use
        /// @apilevel 4
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLGraphicsClipExtentsInfoArrayEx
        {
            /// <summary>
            /// Struct API version
            /// </summary>
            public uint version;

            /// <summary>
            /// The number of virtual cameras
            /// </summary>
            public uint num_virtual_cameras;

            /// <summary>
            /// The combined extents for all the virtual cameras, can be used for conservative frustum
            /// culling of all visible content defined by the union of what is visible from all of
            /// the defined virtual cameras
            /// </summary>
            public MlGraphics.MLGraphicsClipExtentsInfo full_extents;

            /// <summary>
            /// The per virtual camera clip extents
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 2)]
            public MlGraphics.MLGraphicsClipExtentsInfo[] virtual_camera_extents;
        }

        /// <summary>
        /// Definition of a single render target defined in MLGraphicsRenderBufferInfo
        /// </summary>
        /// <remarks>
        /// Each render target defines one of the buffered entries color/depth surfaces (with
        /// maximum count defined by MLGraphics_BufferCount) Clients can assume that the handle
        /// provided here will be in the list of handles returned from MLGraphicsBeginFrame
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLGraphicsRenderTarget
        {
            /// <summary>
            /// The width of the target
            /// </summary>
            public uint width;

            /// <summary>
            /// The height of the target
            /// </summary>
            public uint height;

            /// <summary>
            /// The handle (ID) of the 2D texture array, each layer represents a virtual camera
            /// </summary>
            public MlApi.MLHandle id;

            /// <summary>
            /// The surface format of the target
            /// </summary>
            public MlGraphics.MLSurfaceFormat format;
        }

        /// <summary>
        /// Definition of a single buffer entry for all virtual cameras as defined
        /// in MLGraphicsRenderTargetsInfo
        /// </summary>
        /// <remarks>
        /// Each buffer entry can contain a color / depth target and the target is valid
        /// if the handle != 0
        /// Note : When the client specifies the MLGraphicsFlags_NoDepth flag as part of
        /// client creation the depth targets will always be 0
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLGraphicsRenderBufferInfo
        {
            /// <summary>
            /// The color target for this entry
            /// </summary>
            public MlGraphics.MLGraphicsRenderTarget color;

            /// <summary>
            /// The depth target for this entry
            /// </summary>
            public MlGraphics.MLGraphicsRenderTarget depth;
        }

        /// <summary>
        /// The complete definition of all possible buffered entries along with associated metadata
        /// </summary>
        /// <remarks>
        /// Statically defined after successfully creating the client, the MLGraphicsRenderTargetsInfo
        /// provides the definition of all of the buffered entries along with the global metadata The
        /// client can assume that once queried the definition will not change and therefore does not need
        /// to be queried more than once at runtime
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLGraphicsRenderTargetsInfo
        {
            /// <summary>
            /// The enforced minimum clip distance for rendering content, in meters
            /// </summary>
            public float min_clip;

            /// <summary>
            /// The un-enforced, but recommended maximum clip distance for rendering content, in meters
            /// </summary>
            public float max_clip;

            /// <summary>
            /// The total number of virtual camera for this platform,
            /// ie (num_virtual_cameras 
            /// &lt;
            /// = MLGraphicsVirtualCameraName_Count)
            /// </summary>
            public uint num_virtual_cameras;

            /// <summary>
            /// The buffer entries for all virtual cameras
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 3)]
            public MlGraphics.MLGraphicsRenderBufferInfo[] buffers;
        }

        /// <summary>
        /// The per virtual camera information as defined in MLGraphicsVirtualCameraInfoArray
        /// </summary>
        /// <remarks>
        /// For each virtual camera the client is provided the exact definition of the camera properties
        /// along with the matrices needed to construct the full transform chain In general the
        /// transform chain for each virtual camera is defined as MATprojection * inv(MATtransform) for
        /// RHS multiplication
        /// Note : The projection model is asymmetric and clients should not assume any of the
        /// symmetric properties of projection Additionally both the transform and projection will
        /// change per frame and cannot be assumed to be static
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLGraphicsVirtualCameraInfo
        {
            /// <summary>
            /// The FOV left half angle, in radians
            /// </summary>
            public float left_half_angle;

            /// <summary>
            /// The FOV right half angle, in radians
            /// </summary>
            public float right_half_angle;

            /// <summary>
            /// The FOV top half angle, in radians
            /// </summary>
            public float top_half_angle;

            /// <summary>
            /// The FOV bottom half angle, in radians
            /// </summary>
            public float bottom_half_angle;

            /// <summary>
            /// The handle of the sync object to signal after submitting all GPU work for the
            /// virtual camera
            /// </summary>
            public MlApi.MLHandle sync_object;

            /// <summary>
            /// The projection matrix for the virtual camera
            /// </summary>
            public MlTypes.MLMat4f projection;

            /// <summary>
            /// The local space (relative to world) camera transform needed to render content,
            /// inverse is view matrix
            /// </summary>
            public MlTypes.MLTransform transform;

            /// <summary>
            /// The name of the virtual camera
            /// </summary>
            public MlGraphics.MLGraphicsVirtualCameraName virtual_camera_name;
        }

        /// <summary>
        /// Information about the current render frame populated by MLGraphicsBeginFrameEx
        /// @This struct must be populated by calling MLGraphicsFrameInfoInit before being used in
        /// @a call to MLGraphicsBeginFrameEx
        /// @apilevel 7
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLGraphicsFrameInfo
        {
            /// <summary>
            /// Struct API version
            /// </summary>
            public uint version;

            /// <summary>
            /// A reference handle for this frame to be provided at end of frame
            /// </summary>
            public MlApi.MLHandle handle;

            /// <summary>
            /// The handle (ID) of the texture array color surface for the virtual cameras
            /// There is one texture layer per virtual camera
            /// </summary>
            public MlApi.MLHandle color_id;

            /// <summary>
            /// The handle (ID) of the texture array depth surface for the virtual cameras
            /// There is one texture layer per virtual camera
            /// </summary>
            public MlApi.MLHandle depth_id;

            /// <summary>
            /// The common viewport definition for all virtual cameras
            /// </summary>
            public MlTypes.MLRectf viewport;

            /// <summary>
            /// A handle to a synchronization object that must be cast to VkSemaphore
            /// and used during queue submission of a Vulkan app GL apps can ignore this member
            /// </summary>
            public MlApi.MLHandle wait_sync_object;

            /// <summary>
            /// The number of virtual cameras for the frame, each virtual camera is a layer
            /// </summary>
            public uint num_virtual_cameras;

            /// <summary>
            /// The array of virtual cameras to render to for the frame
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 2)]
            public MlGraphics.MLGraphicsVirtualCameraInfo[] virtual_cameras;
        }

        /// <summary>
        /// Performance timing information for the graphics client
        /// </summary>
        /// <remarks>
        /// Populated by MLGraphicsGetClientPerformanceInfo, the performance information
        /// contains all metrics tracked by the graphics system for the specified client
        /// Metrics are calculated using a sliding window and can be used to adjust the
        /// client workload characteristics (ie scale, fidelity, etc)
        /// Note : The internal metrics are also provided, informing the client of both the
        /// CPU and GPU cost of the internal operations of the graphics system (in the client
        /// process)
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public struct MLGraphicsClientPerformanceInfo
        {
            /// <summary>
            /// The average frame start CPU to composition acquisition of the frame, in nanoseconds
            /// </summary>
            public ulong frame_start_cpu_comp_acquire_cpu_ns;

            /// <summary>
            /// The average frame start CPU to frame end GPU, in nanoseconds
            /// </summary>
            public ulong frame_start_cpu_frame_end_gpu_ns;

            /// <summary>
            /// The average frame cadence, CPU start to CPU start, in nanoseconds
            /// </summary>
            public ulong frame_start_cpu_frame_start_cpu_ns;

            /// <summary>
            /// The average frame CPU duration, in nanoseconds
            /// </summary>
            public ulong frame_duration_cpu_ns;

            /// <summary>
            /// The average frame GPU duration, in nanoseconds
            /// </summary>
            public ulong frame_duration_gpu_ns;

            /// <summary>
            /// The average CPU duration for internal operations per frame, in nanoseconds
            /// </summary>
            public ulong frame_internal_duration_cpu_ns;

            /// <summary>
            /// The average GPU duration for internal operations per frame, in nanoseconds
            /// </summary>
            public ulong frame_internal_duration_gpu_ns;
        }

        /// <summary>
        /// Enable shader blob cache for OpenGL
        /// MLResult_InvalidParam Filename parameter null, malformed, or inaccessible to the application
        /// MLResult_Ok Blob cache enabled successfully
        /// </summary>
        /// <param name="filename">Absolute path to a file to use for caching Location must be writeable by application</param>
        /// <param name="max_entry_bytes">Reserved for future use Maximum size for a single blob entry Currently defaults to 512KB</param>
        /// <param name="max_total_bytes">Reserved for future use Maximum total file size for the blob Currently defaults to 8MB</param>
        /// <remarks>
        /// OpenGL can cache 
        /// &amp;
        /// reuse shaders and other driver artifacts using a blob cache,
        /// speeding up loading 
        /// &amp;
        /// processing of shaders significantly on subseqent occurrences
        /// This behavior persists across runs of the app as well, speeding up load times
        /// This function is used to enable the blob caching using the specified file The
        /// file path must be writeable by the application The file will be created if it
        /// doesn't already exist
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLGraphicsEnableBlobCacheGL([MarshalAs(UnmanagedType.LPStr)] string filename, uint max_entry_bytes, uint max_total_bytes);

        /// <summary>
        /// Create the GL/GLES graphics client
        /// MLResult_InvalidParam Graphics Client was not created due to an invalid parameter
        /// MLResult_Ok Graphics Client was created successfully
        /// MLResult_UnspecifiedFailure Graphics Client was not created due to an unknown error
        /// </summary>
        /// <param name="options">The graphics options for resource creation</param>
        /// <param name="opengl_context">The OpenGL context to use for resource creation</param>
        /// <param name="out_graphics_client">The handle to the created graphics client Only valid if result is MLResult_Ok</param>
        /// <remarks>
        /// Create a graphics client for use with GL/GLES APIs using the provided options and
        /// specified opengl context It is required that the opengl context specified here is
        /// only bound on the thread used to render the client frame and is the same context
        /// used to render the frame using the provided information from MLGraphicsBeginFrame
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLGraphicsCreateClientGL(in MlGraphics.MLGraphicsOptions options, MlApi.MLHandle opengl_context, ref MlApi.MLHandle out_graphics_client);

        /// <summary>
        /// Convert MLSurfaceFormat to OpenGL internal format
        /// </summary>
        /// <param name="format">The MLSurfaceFormat to convert</param>
        /// <returns>
        /// The returned internal format
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern uint MLGraphicsGLFormatFromMLSurfaceFormat(MlGraphics.MLSurfaceFormat format);

        /// <summary>
        /// Convert OpenGL internal format to MLSurfaceFormat
        /// </summary>
        /// <param name="format">The internal format to convert</param>
        /// <returns>
        /// The returned MLSurfaceFormat
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlGraphics.MLSurfaceFormat MLGraphicsMLSurfaceFormatFromGLFormat(uint format);

        /// <summary>
        /// Destroy a GL/GLES or VK client
        /// MLResult_InvalidParam Graphics Client was not destroyed due to an invalid parameter
        /// MLResult_Ok Graphics Client was destroyed successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </summary>
        /// <param name="graphics_client">The graphics client to destroy</param>
        /// <remarks>
        /// Destroying the client will invalidate all resources associated with the client handle
        /// and invalidate the provided handle
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLGraphicsDestroyClient(ref MlApi.MLHandle graphics_client);

        /// <summary>
        /// Set the frame timing hint, can be set at runtime and is updated on the
        /// next call to MLGraphicsBeginFrame
        /// MLResult_InvalidParam Timing Hint was not changed due to an invalid parameter
        /// MLResult_Ok Timing Hint was changed successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </summary>
        /// <param name="graphics_client">The graphics client to modify</param>
        /// <param name="hint">The graphics frame timing hint</param>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLGraphicsSetFrameTimingHint(MlApi.MLHandle graphics_client, MlGraphics.MLGraphicsFrameTimingHint hint);

        /// <summary>
        /// Request to begin rendering a new frame in the graphics system
        /// MLResult_InvalidParam Frame was not started due to an invalid parameter
        /// MLResult_Ok Frame was started successfully
        /// MLResult_Timeout Blocking timeout limit reached
        /// MLResult_UnspecifiedFailure Frame was not started due to an unknown error
        /// </summary>
        /// <param name="graphics_client">The graphics client to query</param>
        /// <param name="params">The frame parameters for the frame</param>
        /// <param name="out_frame_info">Information returned for use when rendering the frame Only valid if result is MLResult_Ok</param>
        /// <remarks>
        /// Called to request the start of a new render frame and should be called as close as possible to
        /// the start of rendering to minimize the motion to photon latency Only one frame can be rendered
        /// at a time and must be submitted by providing the returned handle to MLGraphicsEndFrame prior to
        /// another call to MLGraphicsBeginFrameEx The call to begin/end frame should be made on the render
        /// thread alone of the client It is required that a successful call to MLGraphicsFrameInfoInit
        /// be made before calling MLGraphicsBeginFrameEx Faiure to call MLGraphicsFrameInfoInit before
        /// calling MLGraphicsBeginFrameEx will return a result of MLResult_NotImplemented
        /// Note : Calls to MLGraphicsBeginFrameEx can and will block the calling process There are several reasons
        /// that lead to a block, including, the client is executing faster than the defined timing requested (and the
        /// block re-aligns the client timing), the client is not yet visible in the system, and the compositor has
        /// not yet moved to the next buffered entry (ie wraparound cases from fast client rendering) The call
        /// to MLGraphicsBeginFrameEx will timeout the block and return when the conditions to unblock have not
        /// been satisfied for the internal timeout period The most common occurrence of the timeout is when the
        /// application is not currently visible
        /// @apilevel 2
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLGraphicsBeginFrameEx(MlApi.MLHandle graphics_client, in MlGraphics.MLGraphicsFrameParamsEx @params, ref MlGraphics.MLGraphicsFrameInfo out_frame_info);

        /// <summary>
        /// Signal the sync object provided for each virtual camera for GL/GLES clients
        /// MLResult_InvalidParam Sync Object was not signaled due to an invalid parameter
        /// MLResult_Ok Sync Object was signaled successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </summary>
        /// <param name="graphics_client">The graphics client owning the sync object</param>
        /// <param name="sync_object">The sync object to be signaled</param>
        /// <remarks>
        /// Required for each frame, after rendering each virtual camera (or multiple if stereo rendering)
        /// to signal the sync object in order to inform the graphics system that the rendering for the
        /// camera(s) has completed All sync objects can be signaled after rendering all cameras, but
        /// results in lower fidelity in the graphics system
        /// Note: Vulkan clients are required to cast the sync object to VkSemaphore and add it to
        /// the signal semaphore list when submitting the last command buffer for the virtual camera(s)
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLGraphicsSignalSyncObjectGL(MlApi.MLHandle graphics_client, MlApi.MLHandle sync_object);

        /// <summary>
        /// EXPERIMENTAL
        /// Get the conservative clip extents information for each virtual camera
        /// MLResult_InvalidParam Clip Extents not obtained due to an invalid parameter
        /// MLResult_Ok Clip Extents obtained successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </summary>
        /// <param name="graphics_client">The graphics client to query</param>
        /// <param name="params">The clip extents parameters</param>
        /// <param name="out_array">The clip extents info array with all information required for update of each virtual camera
        /// Only valid if result is MLResult_Ok</param>
        /// <remarks>
        /// Clients should call this function once a frame to get the most accurate clip extents
        /// @apilevel 4
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLGraphicsGetClipExtentsEx(MlApi.MLHandle graphics_client, in MlGraphics.MLGraphicsClipExtentsParams @params, ref MlGraphics.MLGraphicsClipExtentsInfoArrayEx out_array);

        /// <summary>
        /// Get a list of all buffered entries
        /// MLResult_InvalidParam Render Targets not obtained due to an invalid parameter
        /// MLResult_Ok Render Targets obtained successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </summary>
        /// <param name="graphics_client">The graphics client to query</param>
        /// <param name="out_targets">The render target info array Only valid if result is MLResult_Ok</param>
        /// <remarks>
        /// Called after client initialization to obtain the definition of all buffered entries
        /// along with the associated metadata Like MLGraphicsGetClipExtents can be assumed that
        /// the output is unchanging for the lifetime of the client
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLGraphicsGetRenderTargets(MlApi.MLHandle graphics_client, ref MlGraphics.MLGraphicsRenderTargetsInfo out_targets);

        /// <summary>
        /// Submit a completed frame to the graphics system
        /// MLResult_InvalidParam Frame not ended due to an invalid parameter
        /// MLResult_Ok Frame ended successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </summary>
        /// <param name="graphics_client">The graphics client to update</param>
        /// <param name="handle">The handle provided from the call to MLGraphicsBeginFrame</param>
        /// <remarks>
        /// Submit a completed frame to the graphics system using the handle provided from
        /// MLGraphicsBeginFrame Prior to submiting the frame the client must signal the sync objects
        /// provided by MLGraphicsBeginFrame, for GL/GLES clients with MLGraphicsSignalSyncObjectGL or
        /// for VK clients including that sync object as part of the signal semaphore list For VK clients,
        /// the color and depth surfaces can be in any image layout when calling MLGraphicsEndFrame
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLGraphicsEndFrame(MlApi.MLHandle graphics_client, MlApi.MLHandle handle);

        /// <summary>
        /// Obtain latest performance metrics for the client
        /// MLResult_InvalidParam Client Performance Info not obtained due to an invalid parameter
        /// MLResult_Ok Render Client Performance Info obtained successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </summary>
        /// <param name="graphics_client">The graphics client in which to query the performance</param>
        /// <param name="out_info">Current performance information for the client Only valid if result is MLResult_Ok</param>
        /// <remarks>
        /// Can be called any time after the client has begun rendering frames to obtain the internally tracked
        /// performance metrics for the client and graphics system Updated internally once per completed frame
        /// @priv None
        /// </remarks>
        [DllImport("ml_graphics", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLGraphicsGetClientPerformanceInfo(MlApi.MLHandle graphics_client, ref MlGraphics.MLGraphicsClientPerformanceInfo out_info);
    }
}
